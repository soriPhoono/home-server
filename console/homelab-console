#!/usr/bin/env python3

import os
import string
import random
import shutil

import json
import getpass

from python_on_whales import docker


def generate_compose_map() -> dict[str, str]:
    compose_map = {}

    for root, _, files in os.walk('./docker'):
        for file in files:
            if file.endswith('.yaml') or file.endswith('.yml'):
                compose_map[root.split('/')[-1]] = root

    return compose_map


def create_network(name: str, args: dict[str, str]) -> None:
    print(f'    -- Creating network: {name}')
    print(f'      -- Args: {args}')

    if len(docker.network.list(filters=[('name', name)])) == 0:
        docker.network.create(
            name,
            True,
            'overlay',
            subnet=args.get('subnet', None)
        )
        print(f'      -- Created network: {name}')
    else:
        print(f'      -- Network already exists: {name}')


def create_volume(name: str) -> None:
    print(f'    -- Creating volume: {name}')

    if len(docker.volume.list(filters=[('name', name)])) == 0:
        docker.volume.create(name)
        print(
            f'        -- Created volume: {name}'
        )
    else:
        print(f'      -- Volume already exists: {name}')


def parse_random(input: str) -> tuple[str, int]:
    name, value_str = input.split()
    return (name, int(value_str))


def generate_password(length: int) -> str:
    if length <= 0:
        raise ValueError("Password length must be a positive integer.")

    unsafe_chars = "'\"\\"

    safe_punctuation = "".join(
        c for c in string.punctuation if c not in unsafe_chars)

    all_characters = string.ascii_letters + string.digits + safe_punctuation

    password = ''.join(random.choices(all_characters, k=length))

    return password


def create_secret(name: str, mode: str) -> None:
    print(f'    -- Creating secret: {name}')
    print(f'      -- Mode: {mode}')
    # Placeholder

    if len(docker.secret.list(filters=[('name', name)])) == 0:
        if not os.path.isdir('./secrets'):
            os.mkdir('./secrets')

        with open(f'./secrets/{name}.txt', 'w+') as file:
            match mode:
                case 'secret_input':
                    value = getpass.getpass(f'Secret {name}> ')
                    file.write(value)
                case str() if mode.startswith('random'):
                    _, length = parse_random(mode)
                    file.write(generate_password(length))
                case _:
                    print(
                        f'      -- Error: Unrecognized type: {mode} for secret: {name}')
                    return

        docker.secret.create(name, f'./secrets/{name}.txt')

        print(f'      -- Created secret: {name}')
    else:
        print(f'      -- Secret already exists: {name}')


def handle_metadata(create: bool, stack_name: str, stack_path: str) -> None:
    meta_file_path = os.path.join(stack_path, 'meta.json')

    print('  Ingesting meta.json file...')
    with open(meta_file_path, 'r') as meta_file:
        meta_data = dict(json.load(meta_file))

        for stack in meta_data.get('dependencies', []):
            deploy_stack(stack.split('/')[-1], os.path.join('./docker', stack))

        if create:
            for network, args in meta_data.get('networks', {}).items():
                create_network(network, args)

            for volume in meta_data.get('volumes', []):
                create_volume(volume)

            for secret, args in meta_data.get('secrets', {}).items():
                create_secret(secret, args)


def deploy_stack(stack_name: str, stack_path: str) -> None:
    print(
        f'Deploying stack: {stack_name} from {stack_path}')

    # Create the stack after dependencies have been created
    if len(list(filter(
            lambda stack: stack.name == stack_name,
            docker.stack.list()
    ))) == 0:
        print(f'  -- Stack {stack_name} does not exist, creating now')

        # Ingest the meta.json file if it exists
        meta_file_path = os.path.join(stack_path, 'meta.json')
        if os.path.isfile(meta_file_path):
            handle_metadata(True, stack_name, stack_path)

        docker.stack.deploy(
            stack_name,
            os.path.join(stack_path, 'docker-compose.yml')
        )
    else:
        print(f'  -- Stack {stack_name} exists, updating!')
        meta_file_path = os.path.join(stack_path, 'meta.json')
        if os.path.isfile(meta_file_path):
            handle_metadata(False, stack_name, stack_path)

        docker.stack.deploy(
            stack_name,
            os.path.join(stack_path, 'docker-compose.yml')
        )

    print('Processed stack: {stack_name}')


def deploy() -> None:
    compose_map = generate_compose_map()

    print('Deploying homelab stack...')
    # Placeholder for deployment logic
    # e.g., python_on_whales.docker.compose.up(detach=True)

    for stack_name, stack_path in compose_map.items():
        deploy_stack(stack_name, stack_path)

    print('Deployment complete.')

    if os.path.isdir('./secrets'):
        shutil.rmtree('./secrets')

    print('Deleted secrets directory, all secrets required have been created')


def main():
    print('----------------------------------')
    print('  Welcome to the Homelab Console  ')
    print('----------------------------------')
    print()
    print("Type 'help' to see available commands.")

    while True:
        try:
            command = input('homelab> ').strip().lower()

            match command:
                case 'deploy':
                    deploy()
                case 'teardown':
                    print('Tearing down homelab stack...')
                    # Placeholder for teardown logic
                    # e.g., python_on_whales.docker.compose.down()
                    print('Teardown complete.')
                case 'help':
                    print('Available commands:')
                    print('---------------------------------------')
                    print('  deploy - Deploy the homelab stack using Docker Compose')
                    print('  teardown - Tear down the homelab stack')
                    print('  help - Show this help message')
                    print('  quit - Exit the console')
                    print('---------------------------------------')
                case 'quit':
                    print('Exiting Homelab Console. Goodbye!')
                    break
                case _:
                    print(
                        f"Unknown command: '{command}'. Type 'help' for a list of commands."
                    )
        except KeyboardInterrupt:
            print('\nExiting Homelab Console. Goodbye!')
            break


if __name__ == '__main__':
    main()
